WEBVTT - This file was automatically generated by VIMEO

0
00:00:02.500 --> 00:00:06.200
No, a graph is a data

1
00:00:05.200 --> 00:00:06.400
 structure.

2
00:00:07.600 --> 00:00:08.700
That has edges.

3
00:00:10.900 --> 00:00:11.000
to

4
00:00:12.300 --> 00:00:15.300
multiple vertices a special

5
00:00:15.300 --> 00:00:16.700
 type of graph is a tree

6
00:00:20.800 --> 00:00:23.300
it's a special type of graph in which

7
00:00:24.800 --> 00:00:25.500
the edges

8
00:00:27.600 --> 00:00:29.800
are not circular they do not.

9
00:00:30.600 --> 00:00:32.800
Go back to the same vertex again.

10
00:00:33.600 --> 00:00:35.000
So it's very one way.

11
00:00:35.600 --> 00:00:37.700
You can see here at the in this particular.

12
00:00:38.700 --> 00:00:39.800
graph

13
00:00:41.400 --> 00:00:44.100
at introducing some terminology we call this

14
00:00:44.100 --> 00:00:44.400
 a

15
00:00:46.400 --> 00:00:49.400
Typically in Tree in trees we

16
00:00:49.400 --> 00:00:52.900
 call that we call these vertices nodes, but again

17
00:00:52.900 --> 00:00:55.300
 the word is interchangeable. So we have these nodes.

18
00:00:56.200 --> 00:00:59.300
And then we have these sub branches. We have the branch on

19
00:00:59.300 --> 00:01:00.400
 the left and the branch on the right.

20
00:01:01.100 --> 00:01:02.100
and we call the

21
00:01:03.500 --> 00:01:03.900
edges

22
00:01:04.800 --> 00:01:07.500
at the end of the tree. This is like a tree turned

23
00:01:07.500 --> 00:01:10.400
 upside down right where the roots of the tree are

24
00:01:10.400 --> 00:01:13.800
 at the top and the leaves are at

25
00:01:13.800 --> 00:01:17.100
 the bottom. So if you can imagine a tree that has turned upright.

26
00:01:18.200 --> 00:01:21.400
so if we have a node that does not Branch off to

27
00:01:21.400 --> 00:01:23.700
 any other node, we call those leaves right because

28
00:01:25.600 --> 00:01:27.000
it's analogous to a tree right?

29
00:01:29.100 --> 00:01:29.700
It turns out.

30
00:01:30.800 --> 00:01:34.400
Trees are very good for searching for

31
00:01:34.400 --> 00:01:37.100
 values very quickly.

32
00:01:38.300 --> 00:01:40.000
Let me show you an example of a binary tree.

33
00:01:41.800 --> 00:01:44.700
Now here's a binary tree a

34
00:01:44.700 --> 00:01:45.300
 pectoral.

35
00:01:46.400 --> 00:01:49.400
better pectoral representation of it and if you

36
00:01:49.400 --> 00:01:50.800
 haven't seen one take a moment to

37
00:01:53.500 --> 00:01:55.900
see why it's ordered the way it is.

38
00:01:56.800 --> 00:01:58.000
So this is a sequence of

39
00:01:58.800 --> 00:01:59.300
numbers

40
00:02:00.200 --> 00:02:01.400
from 1 to 21

41
00:02:02.100 --> 00:02:03.300
some of the numbers are missing.

42
00:02:04.500 --> 00:02:05.900
but the binding tree is

43
00:02:09.600 --> 00:02:13.200
arranged and really its purpose is to search

44
00:02:12.200 --> 00:02:13.400
 for

45
00:02:14.800 --> 00:02:18.600
values very quickly efficiently

46
00:02:19.800 --> 00:02:22.700
when the position of that particularly value

47
00:02:22.700 --> 00:02:23.400
 is unknown.

48
00:02:24.200 --> 00:02:28.100
So if you see here the smallest number in

49
00:02:27.100 --> 00:02:28.300
 this.

50
00:02:29.100 --> 00:02:29.900
a set of

51
00:02:30.600 --> 00:02:31.700
numbers is one.

52
00:02:33.200 --> 00:02:36.500
Which is at the very far left and if you look at the very far, right

53
00:02:36.500 --> 00:02:39.600
 you will see that it is the largest value of

54
00:02:39.600 --> 00:02:40.200
 this collection.

55
00:02:42.100 --> 00:02:45.800
And then if you look at the root node or

56
00:02:45.800 --> 00:02:48.000
 the root vertex, if you like we have the number

57
00:02:48.000 --> 00:02:48.400
 10.

58
00:02:49.400 --> 00:02:52.100
Which is the number between 1 and 21?

59
00:02:55.100 --> 00:02:56.200
If we have an array.

60
00:02:57.600 --> 00:02:58.600
Which is a linear.

61
00:03:03.700 --> 00:03:04.700
a collection of numbers

62
00:03:05.700 --> 00:03:08.200
then searching that list for a

63
00:03:08.200 --> 00:03:09.900
 particular number can take

64
00:03:12.200 --> 00:03:12.600
we say

65
00:03:14.900 --> 00:03:15.800
linear time

66
00:03:17.800 --> 00:03:20.700
if you remember earlier, I mentioned something called time complexity.

67
00:03:21.400 --> 00:03:22.700
It's time complexity.

68
00:03:23.700 --> 00:03:26.200
worst case and in worst case we did not

69
00:03:26.200 --> 00:03:27.600
 work case with all of an

70
00:03:29.300 --> 00:03:30.300
with Big O

71
00:03:31.600 --> 00:03:32.300
it will be in.

72
00:03:33.900 --> 00:03:36.600
What does that mean? It means that if you have a list with

73
00:03:38.400 --> 00:03:39.500
a 100 values

74
00:03:40.300 --> 00:03:44.000
And let's see you're searching for the number 100. Let's say

75
00:03:43.200 --> 00:03:46.700
 have a list of numbers going from 1 to 100 and you

76
00:03:46.700 --> 00:03:49.300
 do not know for some reason you do not know where the

77
00:03:49.300 --> 00:03:50.100
 number 100 is.

78
00:03:51.400 --> 00:03:54.200
If you want to find that number you have to start counting from left.

79
00:03:55.500 --> 00:03:56.700
all the way to the right

80
00:03:59.500 --> 00:04:02.100
and it's called and it's all of n because

81
00:04:04.400 --> 00:04:07.600
the number of times that you have to search for the

82
00:04:07.600 --> 00:04:09.100
 value is

83
00:04:11.300 --> 00:04:14.400
equivalent to the number of elements you have in the

84
00:04:14.400 --> 00:04:17.700
 list. So if you have a hundred values and you're looking for particular value

85
00:04:18.500 --> 00:04:21.200
worst case scenario will be at the end of the list. So you have to go to

86
00:04:21.200 --> 00:04:22.700
 the entire list to find what you're looking for.

87
00:04:24.200 --> 00:04:27.400
Now, of course you could be lucky and it appears somewhere in the beginning or maybe in the

88
00:04:27.400 --> 00:04:27.500
 middle.

89
00:04:28.600 --> 00:04:31.500
But when we calculate the time complexity of an algorithm we

90
00:04:31.500 --> 00:04:34.200
 want to count or we want to take you

91
00:04:34.200 --> 00:04:37.900
 to count the worst case now. We want to be prepared for the worst possible

92
00:04:37.900 --> 00:04:39.100
 scenario.

93
00:04:41.100 --> 00:04:43.200
Now with an array

94
00:04:43.900 --> 00:04:46.800
The problem can get exasperated.

95
00:04:48.100 --> 00:04:51.000
And the time complexity can be greater.

96
00:04:52.600 --> 00:04:55.200
As the data structure gets bigger. So if you have a million

97
00:04:55.200 --> 00:04:58.200
 values or 10 million values worst case

98
00:04:58.200 --> 00:05:01.100
 now, you have to search through the 10 to the entire collection of

99
00:05:01.100 --> 00:05:04.200
 talent million values to find what you're

100
00:05:04.200 --> 00:05:05.700
 looking for. So it's not efficient.

101
00:05:07.400 --> 00:05:10.600
Arrays are not efficient if for searching for

102
00:05:10.600 --> 00:05:11.000
 things.

103
00:05:13.500 --> 00:05:15.600
When the position of that thing is not no.

104
00:05:16.600 --> 00:05:17.700
enter the binary tree

105
00:05:18.300 --> 00:05:22.500
So you see here we have like I said a range

106
00:05:22.500 --> 00:05:23.600
 of values from 1 to 21.

107
00:05:24.300 --> 00:05:27.300
And at the root we have the number 10. So say you're

108
00:05:27.300 --> 00:05:28.400
 looking for the number 17.

109
00:05:30.300 --> 00:05:33.300
The way you would search for the number 17 in an array is

110
00:05:33.300 --> 00:05:34.700
 to start counting from laughter, right?

111
00:05:36.300 --> 00:05:38.100
Whereas in an array, you don't do that.

112
00:05:38.900 --> 00:05:41.200
In a binary trimmer to say you don't

113
00:05:41.200 --> 00:05:44.400
 do that in a binary tree you go through root note and you ask yourself this

114
00:05:44.400 --> 00:05:46.700
 oh, this is what the algorithm will do.

115
00:05:47.500 --> 00:05:50.600
Is the number 17 less than or greater

116
00:05:50.600 --> 00:05:51.200
 than 10?

117
00:05:52.200 --> 00:05:55.500
Well, that's greater than 10 and because it's greater

118
00:05:55.500 --> 00:05:58.700
 than 10. We can eliminate the entire left Branch

119
00:05:58.700 --> 00:06:01.400
 altogether, so we don't even have to look at this part.

120
00:06:03.400 --> 00:06:05.100
Now then we turn to the right branch.

121
00:06:07.300 --> 00:06:09.300
with node 19 and we ask

122
00:06:09.900 --> 00:06:12.200
Is 17 less than or greater than

123
00:06:12.200 --> 00:06:14.100
 19? It's less than

124
00:06:15.500 --> 00:06:18.000
and so we now this is this is a

125
00:06:18.100 --> 00:06:20.600
 very shallow trees so it will take

126
00:06:23.600 --> 00:06:24.500
I mean we have reached our

127
00:06:25.800 --> 00:06:27.400
matching element

128
00:06:28.300 --> 00:06:31.000
But I hope you I get the idea we were able to have.

129
00:06:32.600 --> 00:06:33.600
the search time

130
00:06:36.500 --> 00:06:38.300
using this data structure

131
00:06:39.200 --> 00:06:43.200
now the time complexity of the binary

132
00:06:42.200 --> 00:06:45.300
 tree this binary the binary

133
00:06:45.300 --> 00:06:46.100
 tree data structure.

134
00:06:47.300 --> 00:06:50.400
And in terms of Big O in terms of the worst case scenario is

135
00:06:50.400 --> 00:06:52.700
 log base 2 of n

136
00:06:53.900 --> 00:06:57.100
y log base 2 event because you are repeatedly having

137
00:06:56.100 --> 00:06:58.000
 each branch.

138
00:06:59.100 --> 00:07:01.300
So it's even better than having the search time.

139
00:07:02.900 --> 00:07:05.700
So if you want to search for values whose

140
00:07:05.700 --> 00:07:08.700
 positions are not known this is the data

141
00:07:08.700 --> 00:07:12.300
 structure you want to go with now, like I said, this is one variant

142
00:07:11.300 --> 00:07:14.400
 of a graph data structure.

143
00:07:14.400 --> 00:07:18.500
 So trees are variations of Greeks of graph.

144
00:07:17.500 --> 00:07:18.700
 Excuse me.

145
00:07:19.700 --> 00:07:22.600
databases Implement something called the

146
00:07:22.600 --> 00:07:23.300
 B3

147
00:07:25.200 --> 00:07:29.100
databases have to be be able to contain large

148
00:07:28.100 --> 00:07:30.700
 volumes of data.

149
00:07:31.400 --> 00:07:32.400
But also make it.

150
00:07:35.700 --> 00:07:38.200
They also have to be very quick in finding

151
00:07:38.200 --> 00:07:41.300
 it particular value in the large collection. So the

152
00:07:41.300 --> 00:07:44.000
 the Implement something called a b tree if you want to learn more

153
00:07:44.200 --> 00:07:47.000
 about those, like I said look in the look at the video description.

154
00:07:47.800 --> 00:07:47.900
to

155
00:07:49.200 --> 00:07:51.900
learn more about graph data structures

156
00:07:52.700 --> 00:07:54.600
and graphs in general

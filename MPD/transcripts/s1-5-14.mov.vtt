WEBVTT - This file was automatically generated by VIMEO

0
00:00:00.500 --> 00:00:02.000
But coming back to my question, I think.

1
00:00:03.300 --> 00:00:06.200
Well, we're all familiar with what a binary trees no matter what is purposes. But

2
00:00:06.200 --> 00:00:07.000
 how do we implement this?

3
00:00:07.800 --> 00:00:10.100
With which one of those four destructors would implement this?

4
00:00:13.600 --> 00:00:16.100
Actually, the dictionary is the right answer because with the two pull.

5
00:00:16.700 --> 00:00:19.800
You have two limitations number one the keys

6
00:00:19.800 --> 00:00:21.300
 are indexed.

7
00:00:22.900 --> 00:00:25.000
Number two, you cannot restructure it.

8
00:00:26.300 --> 00:00:27.200
He said the Tuple is

9
00:00:27.800 --> 00:00:28.600
immutable

10
00:00:29.500 --> 00:00:32.000
let's start sets. Don't even allow you to

11
00:00:32.100 --> 00:00:35.900
 have keys and let's are like tuples they

12
00:00:35.900 --> 00:00:37.900
 are indexed which brings us to dictionaries.

13
00:00:38.900 --> 00:00:40.800
So let me show you how you can Implement a

14
00:00:44.700 --> 00:00:46.300
binary tree with a dictionary

15
00:00:48.900 --> 00:00:50.200
So let's say we have a binary tree.

16
00:00:53.400 --> 00:00:55.100
Okay, what are the values?

17
00:00:55.900 --> 00:00:56.800
1 2 3

18
00:00:58.200 --> 00:01:00.200
Five and six, let's do that one exactly.

19
00:01:01.300 --> 00:01:04.400
So we have one two, three five and

20
00:01:04.400 --> 00:01:04.500
 six.

21
00:01:07.300 --> 00:01:09.200
What is the root note the root note is one?

22
00:01:10.500 --> 00:01:13.000
So what I'm going to do is I'm going to put my first node in here.

23
00:01:15.400 --> 00:01:18.500
So I will say node.

24
00:01:21.900 --> 00:01:22.700
with value 1

25
00:01:24.700 --> 00:01:27.400
but this node branches off to two other nodes.

26
00:01:30.100 --> 00:01:31.800
And it has a left child and a right child.

27
00:01:32.500 --> 00:01:33.500
So it's left child.

28
00:01:36.800 --> 00:01:38.100
And it's right child.

29
00:01:43.400 --> 00:01:44.600
It's left child is what?

30
00:01:46.600 --> 00:01:46.700
two

31
00:01:47.900 --> 00:01:50.100
Right, but we can just say

32
00:01:50.100 --> 00:01:51.300
 two or three here because well.

33
00:01:52.600 --> 00:01:53.200
It's children.

34
00:01:54.800 --> 00:01:55.400
are also

35
00:01:59.900 --> 00:02:00.600
dictionaries

36
00:02:01.700 --> 00:02:04.300
so we have to open up another pair of curly brackets

37
00:02:04.300 --> 00:02:05.900
 for both the left and right child.

38
00:02:06.800 --> 00:02:08.900
It's left child will be just like its parent.

39
00:02:12.500 --> 00:02:15.400
I just want to be I want to indent this so it's

40
00:02:15.400 --> 00:02:18.100
 clear what's going on in here. The left child will also have

41
00:02:18.100 --> 00:02:19.000
 a node.

42
00:02:19.700 --> 00:02:22.200
Element it's value will be two.

43
00:02:23.200 --> 00:02:25.900
And it's left child. Well, let's come back to the children in a moment.

44
00:02:26.600 --> 00:02:28.400
But every node will have a left child.

45
00:02:30.600 --> 00:02:33.300
Or it may they may have a left chart in

46
00:02:33.300 --> 00:02:33.700
 a right child.

47
00:02:34.700 --> 00:02:34.800
Okay.

48
00:02:36.300 --> 00:02:38.400
And for the right child, I'm just going to copy this bit.

49
00:02:40.700 --> 00:02:42.000
The node will be three.

50
00:02:43.300 --> 00:02:43.400
Okay.

51
00:02:44.400 --> 00:02:47.900
Now what children do to do two

52
00:02:47.900 --> 00:02:50.500
 and three have two has two children five and

53
00:02:50.500 --> 00:02:52.800
 six so it's left child.

54
00:02:54.400 --> 00:02:57.100
Let me do three first because this is okay three has no

55
00:02:57.100 --> 00:02:59.800
 children. So this will be none.

56
00:03:00.400 --> 00:03:02.400
And it's right child will be done.

57
00:03:03.600 --> 00:03:05.000
Okay, so it's a leaf in other words.

58
00:03:06.300 --> 00:03:07.200
but the left child

59
00:03:09.200 --> 00:03:10.400
will have two more nodes.

60
00:03:12.600 --> 00:03:12.900
Okay.

61
00:03:15.900 --> 00:03:17.300
I can I'm gonna expand this.

62
00:03:19.600 --> 00:03:21.600
It's node will be 5.

63
00:03:23.600 --> 00:03:24.600
left child

64
00:03:26.400 --> 00:03:27.300
Does it have any children?

65
00:03:28.400 --> 00:03:30.400
It has no children, so this will be none.

66
00:03:31.700 --> 00:03:32.900
And it has no right children.

67
00:03:34.400 --> 00:03:35.900
No, right child, so this would be not.

68
00:03:36.500 --> 00:03:36.900
oops

69
00:03:38.500 --> 00:03:39.300
Sorry about that.

70
00:03:40.500 --> 00:03:41.600
Right child will be.

71
00:03:43.900 --> 00:03:45.300
and same thing for

72
00:03:46.800 --> 00:03:48.400
the right child of number two

73
00:03:50.600 --> 00:03:54.000
The right child has no is annuit value

74
00:03:53.000 --> 00:03:54.200
 6.

75
00:03:55.900 --> 00:03:58.000
now if you look at this, it's kind of

76
00:03:59.600 --> 00:04:01.200
we're building right? I mean it's a lot of

77
00:04:02.600 --> 00:04:03.800
A lot a lot going on in here.

78
00:04:04.800 --> 00:04:04.900
but

79
00:04:07.500 --> 00:04:08.100
we could do it.

80
00:04:09.400 --> 00:04:12.400
Now you're actually implemented this way. This is not a practical way

81
00:04:12.400 --> 00:04:13.000
 to implement.

82
00:04:14.100 --> 00:04:17.200
Binary ideally, what you would do is you would

83
00:04:17.200 --> 00:04:17.900
 create a class.

84
00:04:19.200 --> 00:04:22.300
And Abstract away the process of adding a

85
00:04:22.300 --> 00:04:22.500
 child.

86
00:04:24.100 --> 00:04:26.600
Or removing a child or searching for a child.

87
00:04:27.400 --> 00:04:30.600
Okay, so why you can't do this? Obviously, I

88
00:04:30.600 --> 00:04:33.300
 mean, this is a tiny binary tree by look up look at

89
00:04:33.300 --> 00:04:34.500
 the size of this thing. It's hideous.

90
00:04:35.100 --> 00:04:38.300
We will look at how we can how we would create a binary tree

91
00:04:38.300 --> 00:04:38.500
 class.

92
00:04:39.400 --> 00:04:42.300
Add methods for adding child searching for

93
00:04:42.300 --> 00:04:44.600
 child rebalancing the tree all that good stuff.

94
00:04:45.500 --> 00:04:47.400
Okay, but let me collapse this.

95
00:04:50.100 --> 00:04:51.800
Can you tell me how we can access?

96
00:04:53.900 --> 00:04:54.300
six

97
00:04:56.200 --> 00:04:59.500
What do I need to type here online 218 to access?

98
00:05:00.800 --> 00:05:02.800
the value 6 in this binary tree

99
00:05:04.500 --> 00:05:07.200
Let me let's at least start with the first one. How do we access the

100
00:05:07.200 --> 00:05:08.000
 root node?

101
00:05:10.700 --> 00:05:12.100
How do we access the root node?

102
00:05:13.500 --> 00:05:13.800
Okay.

103
00:05:14.800 --> 00:05:18.200
I just showed you how to get to the node root node.

104
00:05:19.100 --> 00:05:22.100
Okay, so we can get one. But now how do I get to the

105
00:05:26.400 --> 00:05:29.800
Sixth the number six. So what I

106
00:05:29.800 --> 00:05:30.800
 need to do is first go left.

107
00:05:32.200 --> 00:05:32.600
Then go right.

108
00:05:33.900 --> 00:05:36.400
So I need to go to the left node. And

109
00:05:36.400 --> 00:05:39.800
 then from there go to the right notes. I will type in here instead of

110
00:05:39.800 --> 00:05:42.200
 binary tree. No, I would say left.

111
00:05:43.800 --> 00:05:44.100
child

112
00:05:45.500 --> 00:05:47.300
and if I want to confirm I can type in node.

113
00:05:48.600 --> 00:05:49.600
This will give you number two.

114
00:05:50.900 --> 00:05:52.700
but if I want to go to number six

115
00:05:53.500 --> 00:05:56.200
after I go to Left child, I have to visit the right child.

116
00:05:58.400 --> 00:05:59.600
And then I will type a note.

117
00:06:02.700 --> 00:06:04.100
There we have it.

118
00:06:10.100 --> 00:06:12.600
So later on especially in module 3 when we

119
00:06:15.500 --> 00:06:17.200
are going to build binary trees.

120
00:06:18.200 --> 00:06:20.100
And we'll look at other graph data structures.

121
00:06:20.900 --> 00:06:23.700
This is what our data structure will look like now.

122
00:06:23.700 --> 00:06:26.700
 Like I said, we won't do it this way. This is a this is

123
00:06:26.700 --> 00:06:29.100
 a very bad way. You can just see even with the small example. I

124
00:06:29.100 --> 00:06:32.700
 ran into errors rather. We will create classes like

125
00:06:32.700 --> 00:06:35.300
 class binary tree and then

126
00:06:35.300 --> 00:06:38.600
 we will have methods for adding removing searching

127
00:06:38.900 --> 00:06:39.000
 Etc.
